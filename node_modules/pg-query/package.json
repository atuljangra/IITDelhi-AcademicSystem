{
  "name": "pg-query",
  "version": "0.11.0",
  "description": "Execute postgres queries simply.",
  "main": "index.js",
  "scripts": {
    "test": "npm install pg.js && mocha"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/brianc/node-pg-query.git"
  },
  "keywords": [
    "postgres",
    "PostgreSQL"
  ],
  "author": {
    "name": "Brian M. Carlson"
  },
  "license": "MIT",
  "devDependencies": {
    "mocha": "~1.12.0",
    "async": "~0.2.9",
    "sql": "~0.26.0",
    "pg": "*",
    "pg-cursor": "^0.1.3"
  },
  "dependencies": {
    "okay": "~0.3.0",
    "when": "~3.1.0"
  },
  "readme": "# pg-query\n\nRun queries with node-postgres with less boilerplate.  node-posgres is low level by design and rather verbose.\n\nThis is a simple abstraction I've spun into a module after implementing something like this in most of my projects.\n\n## install\n\n`npm install pg-query`\n\n## use\n\n```js\nvar query = require('pg-query');\n\nquery('SELECT NOW()', function(err, rows, result) {\n  assert.equal(rows, result.rows);\n});\n\n```\n\nNotice the callback is called with 3 parameters.\nFirst the `error` argument.\nNext the __rows__ returned by the query.\nFinally the full __result__ object which contains the same reference to the rows at `result.rows`\n\n## more examples\n```js\nvar query = require('pg-query');\nquery.connectionParameters = 'postgres://user:password@host:5432/database';\n\n//accepts optional array of values as 2nd parameter for parameterized queries\nquery('SELECT $1::text as name', ['brian'], function(err, rows, result) {\n\n});\n```\n\nIf a callback is not passed, a promise is returned that will be resolved with `[rows, result]`\n\n```js\nvar query = require('pg-query');\nquery.connectionParameters = 'postgres://user:password@host:5432/database';\n\n//accepts optional array of values as 2nd parameter for parameterized queries\nvar promise = query('SELECT $1::text as name', ['brian']);\nfunction onSuccess(rows, result) {\n\n}\nfunction onError(error) {\n\n}\npromise.spread(onSuccess, onError);\n```\n\n## query.first(text, [values], [cb])\n\nOften I find I'm getting a single row by ID.  `query.first` allows for easy composition into async structures by returning the first row of the query or null if there are no rows.  Let me show you...\n\n```js\n//this is the old way:\nvar getUserById = function(id, cb) {\n  query('SELECT * FROM \"user\" WHERE id = $1', [id], function(err, rows) {\n    cb(err, rows ? rows[0] : null)\n  })\n}\n\n//this is much easier\nvar getUserById = function(id, cb) {\n  query.first('SELECT * FROM \"user\" WHERE id = $1', id, cb)\n}\n\n//or even this if you're crazy\nvar getUserById = query.first.bind(query, 'SELECT * FROM \"user\" WHERE id = $1')\n```\n\n`query.first` does a bit of argument type checking. If you pass an array as the `values` argument it is passed to the query unchanged. If you pass anything else truthy it is wrapped inside an array. This makes `query.first` easier to compose and use.\n\n\n## comments\n\n`pg-query` is domain aware so your callback will always be called in the correct domain.\nIf you're not using domains it will gracefully ignore them.\n\n`pg-query` uses whichever version of node-postgres you have installed in your project.\n\n`pg-query` uses `pg.defaults` and/or [environment variables](http://www.postgresql.org/docs/9.2/static/libpq-envars.html) to connect.\n\n`pg-query` uses __a random pooled database client for each query__.\nIf you're using a transaction (eg `BEGIN`/`COMMIT`) you need to check out a client from the pool manually.\n__Repeat__: DO NOT USE THIS FOR RUNNING TRANSACTIONS\n\n## todo\n\n- Accept query object\n- Accept anything that responds to `.toQuery` ([node-sql](https://github.com/brianc/node-sql) queries, etc)\n- Possibly add some way to configure connection parameters\n\n## license\n\nMIT\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/brianc/node-pg-query/issues"
  },
  "_id": "pg-query@0.11.0",
  "_from": "pg-query@"
}
